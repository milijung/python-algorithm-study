'''
* 가치의 합이 k원이 되도록 하는 동전 조합의 수
  (vs 동전2: 가치의 합이 k원이 되도록 하는 동전 조합의 최소 개수)
* 여기서는 순서가 달라도 구성이 같으면 같은 경우로 카운트함
  (vs 123더하기: 순서가 다르면 다른 경우로 카운트함)

ex) i = 1
        j=1: dp[1] += dp[0]: 1
        j=2: dp[2] += dp[1]: 1 1
    ... j=k: dp[k] += dp[k-1]: 1 1 ... 1
    i = 2
        j=2: dp[2] += dp[0]: 2
        j=3: dp[3] += dp[1]: 1 2
        j=4: dp[4] += dp[2]: 1 1 2, 2 2
        j=5: dp[5] += dp[3]: 1 1 1 2, 1 2 2
    ... j=k: dp[k] += dp[k-2]
'''
n, k = map(int, input().split())
coins = [int(input()) for _ in range(n)]
dp = [0] * (k+1)
dp[0] = 1 # 동전을 1개만 쓸 때의 경우를 고려하기 위함

for i in coins:
    # 같은 조합은 같은 경우로 카운트해야하므로, 사용하는 동전별로 dp[i]를 계산
    # 사용하는 동전이 겹치지 않으므로, 같은 조합이 중복으로 카운트되지 않음
    for j in range(i, k+1):
        dp[j] += dp[j-i]

print(dp[k])
